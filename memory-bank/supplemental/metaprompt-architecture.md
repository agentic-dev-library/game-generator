# Metaprompt Architecture Design

**Date**: 2025-01-08
**Context**: Major architectural shift to metaprompt-driven generation

## Overview

We've implemented a three-level hierarchy for game generation:

```
Game Config → Metaprompts → Prompts → Game Content
```

## Key Insight

Instead of hardcoding prompts for every possible game combination, we use metaprompts that:
1. Analyze the game's specific configuration
2. Generate tailored prompts based on features, genre, and style
3. Those generated prompts then create the actual game content

## Directory Structure

```
crates/ai_rpg_generator/
├── metaprompts/                 # Generate prompts based on game config
│   ├── master_orchestrator.jinja
│   ├── database/
│   │   └── schema_generator.jinja
│   ├── sprites/
│   │   └── sprite_generator.jinja
│   ├── bootstrap/
│   │   └── project_generator.jinja
│   └── README.md
└── prompts/                     # Generated by metaprompts, create game content
    └── phases/
        └── database/
            └── example_generated.jinja  # Example of metaprompt output
```

## Example Flow

1. **Game Config**: 
   ```json
   {
     "title": "Dragon's Quest",
     "genre": "fantasy RPG", 
     "features": ["combat", "inventory", "dialogue"]
   }
   ```

2. **Metaprompt** (database/schema_generator.jinja) analyzes:
   - "This game needs combat tables"
   - "This game needs inventory tables"
   - "This game needs dialogue tables"

3. **Generated Prompt**:
   ```
   Create SeaORM migrations for a fantasy RPG with:
   - Tables for tracking battle participants and spell cooldowns
   - Item storage with equipment slots
   - Conversation state and NPC relationships
   ```

4. **Final Output**: Actual SeaORM migration code

## Benefits

1. **Infinite Flexibility**: Can handle any combination of features
2. **Consistency**: All generated prompts follow the same patterns
3. **Maintainability**: Change the metaprompt to update all generated prompts
4. **AI-Friendly**: Each level optimized for AI capabilities

## Implementation Notes

- Metaprompts use MinJinja templating
- They receive game configuration as context
- Output is a prompt string that gets sent to AI
- The AI then generates the actual game content

## Database-First Philosophy

All metaprompts emphasize:
- Store game state in SQLite
- ECS components are just markers with UUID references
- Complex data lives in the database, not in Rust structs
- AI excels at generating schemas, not complex behavior code
